```
<?php
$a = 10;//将常量值赋给变量，会为a分配内存空间
$b = $a;//变量赋值给变量，是不是copy了一份副本，b也分配了内存空间呢？
$c = &$a;//引用是不会为c分配空间的，c和a是共用一份空间的。
?>
```
对于中间的那个问题，你的答案是什么呢？在今天之前，我的答案是会为b分配内存空间。因为我是这么理解的：

&赋值的时候，视为一个变量定义了一个别名，增加了一个对内存空间的引用。改变其中一个，会影响其他的引用。而使用unset()时，只是断开了对变量内存空间的引用，内存空间不会释放。

而 = 赋值则不同，它会重新开辟一份内存空间存储原变量的副本。两者之间的修改不会相互影响。

###而下面的程序则印证了这一点：###

```
<?php
$a = 10;//将常量值赋给变量，会为a分配内存空间
$b = $a;//变量赋值给变量，是不是copy了一份副本，b也分配了内存空间呢？
$c = &$a;//引用是不会为c分配空间的，c和a是共用一份空间的。
$a = 5;
echo $c;//输出5，因为a和c 是指向同一个内存空间
echo PHP_EOL;
echo $b;//由于b是副本，对a的操作不会影响b，输出10
?>
```
###那如果###
```
$b = $a;//之后a  和  b 都不做任何改变，保持一致
```
有这么一个问题，如果 = 赋值之后，两个变量都不曾改变，如果是两份副本，岂不是太浪费内存？PHP中实际上避免了这种情况。
###PHP中将一个变量赋值给新变量时，不会立即为新变量分配内存空间，只是增加了对内存空间的引用。当原变量或者新变量作出任何改变时，才会为新变量 分配一块内存空间。###
```
<?php
$a = 1;
$b = $a;
echo $a;
//在此之前，b都是和a共用内存空间的。
$a = 2;//a作出了改变，此时b才会有自己的空间
?>
```
每个php变量存在一个叫"zval"的变量容器中。一个zval变量容器，除了包含变量的类型和值，还包括两个字节的额外信息。第一个是"is_ref"，是个bool值，用来标识这个变量是否是属于引用集合(referenceset)。通过这个字节，php引擎才能把普通变量和引用变量区分开来，由于php允许用户通过使用&来使用自定义引用，zval变量容器中还有一个内部引用计数机制，来优化内存使用。第二个额外字节是"refcount"，用以表示指向这个zval变量容器的变量(也称符号即symbol)个数。当"refcount"的值是1时，"is_ref"的值总是FALSE.
 
安装xdebug之后，利用xdebug_debug_zval(),可以看到zval结构：

如下：

```
<?php
$a = 1;
$b = $a;
echo $a;
//在此之前，b都是和a共用内存空间的。
xdebug_debug_zval('b');
$a = 2;//a作出了改变，此时b才会有自己的空间
xdebug_debug_zval('b');
?>
```
输出：

b:

(refcount=2, is_ref=0),

int 

1

b:

(refcount=1, is_ref=0),

int 

1

####由上面的结果可以看到，在a作出改变之前，引用计数是2 ，当a作出改变之后，b的引用计数变为1，是因为b重新分配了空间对象也能被“克隆”对象总是通过引用传递。对象会提供一个指向自己的引用，而不是复制自己的一个副本。这意味着如果一个函数对传入的一个对象进行操作时，没有必要从函数中返回。这种变化会在对象的原始副本上反映出来。如果需要为一个已经存在的对象复制一个单独的副本，可以使用clone这个关键字来创建#####